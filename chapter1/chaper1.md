+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
## 了解 **_new_**  操作符。  
在js中使用new操作符可以创建一个对象。例如：  
```
function fn(a){
  //"use strict";
  this.a = a
  console.log(this.a);
}
fn(10);//10
var fun = new fn(2);//2
console.log(window.a);//10
console.log(fun.a);//2
```
我定义了一个函数 __*fn()*__, 这个函数在严格模式下会报错 __*Uncaught TypeError*__ ,因为函数中没有定义变量 __*a*__ .  
在非严格模式下，会在全局作用域下创建一个变量 __*a*__ ,并将参数复制给 __*a*__ 我们可以通过 __*window.a*__ 来观察。
而使用 __*new*__  操作符会做四件事情：  
  1. 创建一个{}  
  2. 将该对象的原型指向 __*fn()*__的原型对象  
  3. 改变 __*this*__ , __*this*__ 指向 1 中新建的{}空对象，在该对象上执行__*fn()*__函数  
  4. 如何 __*fn()*__ 函数中没有返回值,则将 1 中新建的对象返回,若有返回值,则按函数返回值返回  
所以在执行``` var fun = new fn(2);//2 ```代码时，fun相当于对象 __*{a:2}*__ 。

## underscore 中定义 *\_()*
  首先，我们来看看underscore中是如何定义 __*\_()*__ 的  
```
  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    debugger;
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };
```
  这里，我们看到,如果去执行以下语句
```
  var obj = {};
  var newObj = _(obj);
```  
  这里会发生什么呢？  
  当第一此调用 __*\_(obj)*__ 时,先判断 __*obj*__ 是否属于 __*\_*__ 这个函数的原型, 如果是则表名该对象已经被 __*\_()*__ 封装,直接返回 __*obj*__ .  
  但此时并未完成封装,所以会跳进下一个 __*if*__ 因为此时以全局方法调用 __*\_()*__ , __*this*__ 会使用默认指向方式，__*this*__ 指向全局作用域。  
  所以进入第二个 __*if*__ 分支, 执行 __*new*__  操作。  
   1. 创建{}  
   2. __*this*__ 指向 __*\_().prototype*__ ;
   3. 在新作用域执行 __*\(obj)*__ 函数, 此时因为作用域发生变化，但是 __*obj*__ 的原型 本身此时并不指向 __*\_*__,而this 指向 __*\_*__  
   所以此时会跳过两个 __*if*__ ,将执行第32行代码，将 __*obj*__ 的引用传递给 1 中新对象.  
   4. 此时函数没有返回值,会将 1 中对象返回。 此时 __*new*__ 结束，执行 __*return*__ 语句,返回对象,将新的被 __*\_()*__ 函数包裹的对象返回给 __*newObj*__ .  
## 这次的分析结束
